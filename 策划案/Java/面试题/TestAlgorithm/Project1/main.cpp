#include<algorithm> #include<cstdio> #include<cstdlib> #include<queue> #include<stack>  using namespace std;   /** problem A Given tow integer a and b, you can perform += so in a and b so that one integer can strictly greater than a given value n. What is the smallest number of operations he has to perform? Input The first line contains a single integer T (1≤T≤100) — the number of test cases.  Each of the following T lines describes a single test case, and contains three integers a,b,n (1≤a,b≤n≤10^9) — initial values of a and b, and the value one of the variables has to exceed, respectively.  Output For each test case print a single integer — the smallest number of operations needed. Separate answers with line breaks.  sample input： 2 1 2 3 5 4 100 sample output 2 7  1. 题目大意是什么？ 5分 2. 编写代码实现。  10分 */  /** 解析 考察英语阅读能力和最基本的编码能力 算法就是比较两个数的大小，小的数被+=。 */  void problem1() { 	int T; 	int a, b, n; 	scanf("%d", &T); 	while (T--) 	{ 		scanf("%d%d%d",&a,&b,&n); 		int times = 0; 		while (a <= n && b <= n) 		{ 			if (a > b) 			{ 				b += a; 			} 			else 			{ 				a += b; 			} 			times++; 		} 		printf("%d\n",times); 	} }      /** problem B 给定两个长度分别为n,m的整型数组A，B，计为A0,A1,A2,...,A(n-1);B0,B1,B2,...,B(m-1) 定义长度为m的数组C，计为C0,C1,C2,...,C(n-1)，Ci的值为数组A中有多少个元素小于Bi，求数组C 输入： n,m（A数组的长度n,n<2*10^5,B数组的长度m,m<2*10^5） a0,a1,...a(n-1)  (ai是个整数) b0,b1,...b(m-1) (bi是个整数) 输出： c0,c1,...,c(bm-1) 样例输入： 5 6 3 5 1 9 6 0 1 2 8 9 10 样例输出： 0 0 1 4 5 5  1. 要求编写一个(m+n)lgn的算法，写清代码实现的思路。 15分 */  /** 解析 对数组A排序，而后遍历数组B，使用二分查找 */  void problem2() { 	int m, n; 	const int MN = 200010; 	const int MM = 200010; 	int *aArr = new int[MN]; 	int *bArr = new int[MM]; 	scanf("%d%d", &n, &m); 	for (int i = 0; i < n; i++) 	{ 		scanf("%d", &aArr[i]); 	} 	for (int i = 0; i < m; i++) 	{ 		scanf("%d", &bArr[i]); 	} 	//先排序再二分查找，暴力求解给5分 	sort(aArr, aArr + n); 	for (int i = 0; i < m; i++) 	{ 		if (i > 0) 			printf(" "); 		if (bArr[i] == aArr[0]) 		{ 			printf("0"); 		} 		else 		{ 			int idx = upper_bound(aArr, aArr + n, bArr[i]) - aArr; 			printf("%d", idx); 		} 	} 	printf("\n"); 	delete[] aArr; 	delete[] bArr; }     /**  problem C 现在需要写一个程序，来判断两个城市是否相连。如果A和B相连，B和C相连，那么A和C也相连。 输入： 第一行输入两个正整数n,m，表示有n（n<100000）个城市，城市编号1~n，m表示城市间有m条通道。 后面n行是通道数据，每行两个整数，a,b,分别表示城市a和城市b有一条通道(a!=b)。 而后输入一个整数T，表示之后有T组问询 而后T行，每行有两个整数x,y(x!=y)，x,y<=n，如果x城市到y城市可联通，则输出YES，否则输出NO。 样例输入： 15 13 1 2 1 3 2 4 5 6 5 7 6 7 8 9 8 10 8 11 10 12 13 14 13 15 15 12 8 1 2 1 4 3 4 3 5 5 7 8 9 13 8 11 14 样例输出： YES YES YES NO YES YES YES YES     1. 该问题用到的算法是什么？（5） 2. 编写代码求解（15） */  /** 解析： 1. 该题应使用并查集 2. 其实代码会写，不需要知道具体用的什么算法，考察递归和数据结构的灵活设计能力。 */  const int PB3_MN = 100000;  int pb3_father[PB3_MN + 1];  int problem3_find(int u) { 	if (u == pb3_father[u]) 	{ 		return u; 	} 	pb3_father[u] = problem3_find(pb3_father[u]); 	return pb3_father[u]; }  void problem3_merge(int a, int b) { 	int fa = problem3_find(a); 	int fb = problem3_find(b); 	if (fa != fb) 	{ 		pb3_father[fb] = a; 	} }  void problem3() { 	int n, m; 	scanf("%d%d", &n, &m); 	for (int i = 1; i <= n; i++) 	{ 		pb3_father[i] = i; 	}  	for (int i = 0; i < m; i++) 	{ 		int a, b; 		scanf("%d%d", &a, &b); 		problem3_merge(a, b); 	}  	int T; 	scanf("%d", &T); 	while (T--) 	{ 		int a, b; 		scanf("%d%d", &a, &b); 		if (problem3_find(a) == problem3_find(b)) 		{ 			printf("YES\n"); 		} 		else 		{ 			printf("NO\n"); 		} 	}  }   /**  problem D 一个m*n的棋盘(n行m列,m,n<100)，象棋马处于ax,ay(0<ax<=m,0<ay<=n),马的目标点是dx,dy(0<dx<=m,0<dy<=n,与马的坐标不同)。 请输入一个马跳到目标点的一个方案，使其使用的步数最少。 输入： m,n,T(T组测试数据) ax,ay,dx,dy 输出: T行数据，格式为： sn步： (ax0,ay0)->(ax1,ay1), (ax1,ay1)->(ax2,ay2), ..., (axsn-1,aysn-1)->(axsn,aysn) 如果无法到达，输出can't reach!  样例输入： 10 10 5 2 1 3 3 2 1 2 3 3 2 2 6 1 1 10 10 1 2 1 1 样例输出： 1步: (2,1) -> (3,3) 2步: (2,1) -> (4,2) -> (2,3) 3步: (3,2) -> (5,3) -> (4,5) -> (2,6) 6步: (1,1) -> (3,2) -> (5,3) -> (7,4) -> (8,6) -> (9,8) -> (10,10) 3步: (1,2) -> (2,4) -> (3,2) -> (1,1)   1. 该问题用到的算法是什么？（5分） 2. 简述代码实现思路，讲清需要定义的数据结构，算法逻辑，可以适当些一些代码来描述。（20分） */  /* 解析： 第1问： 该问题用到宽度优先搜索 第2问： 定义一个m*n的二维数组，标记该点是否被走过 (2分) 定义一个方向数组：dir[8][2] = {{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};(2分) 定义一个Point的二维数组preSetp，记录来到该点上一步的位置(2分) 定义一个队列que，用作宽搜(2分) 定义一个栈st，用于结果输出(2分) 算法： 初始节点入队，初始点标记被访问 while(!que.empty())(2分) {    取出队头元素 curP    如果该点为目标点，则挑出循环    for(int i=0;i<8;i++)(2分)    { 		以curP为出发点，加方向数组中的元素,得到新的坐标点 		Point newP = curP + Point(dir[i][0],dir[i][1]) 		判断新的坐标点是否超出边界或者已被访问，如果没有则入队 		并把该坐标点设置为已访问(2分) 		preSetp的值设置为curP(2分)    } } 从目标点的preSetp数组对应位置开始追溯出发点，每访问到一个点后，把该点如栈，直到把出发点入栈。 Point curP = targetP; while(curP.x != -1)(2分) {    st.push(curP);    curP = preSetp[curP.x][curP.y]; } 而后把输出栈依次出栈，按题中要求格式输出。   */ struct Point { 	int x; 	int y; 	Point(int px, int py) 	{ 		x = px; 		y = py; 	} 	Point() :Point(-1, -1) 	{  	} 	Point operator+  (Point b) 	{ 		return Point(x+b.x,y+b.y); 	}  	bool operator == (Point b) 	{ 		return x == b.x && y == b.y; 	} }; void problem4() { 	int m,n; 	const int MN = 100; 	const int MM = 100; 	unsigned char mapArr[MM][MN]; 	Point preStep[MM][MN]; 	const int dirArr[8][2] = { {2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1} }; 	scanf("%d%d", &n, &m); 	int T; 	scanf("%d", &T); 	while (T--) 	{ 		int ax, ay, dx, dy; 		scanf("%d%d%d%d",&ax,&ay,&dx,&dy); 		Point tarP(dx, dy); 		bool isFind = false; 		// init mapArr 		memset(mapArr, 0, sizeof(mapArr)); 		memset(preStep, -1, sizeof(preStep)); 		Point setupP(ax, ay); 		mapArr[setupP.x][setupP.y] = 1; 		queue<Point> que; 		que.push(setupP); 		while (!que.empty()) 		{ 			Point curP = que.front(); 			que.pop(); 			if (curP == tarP) 			{ 				isFind = true; 				break; 			} 			for (int i = 0; i < 8; i++) 			{ 				Point newP = curP + Point(dirArr[i][0], dirArr[i][1]); 				if (!(newP.x<1 || newP.x>m || newP.y<1 || newP.y>n || mapArr[newP.x][newP.y])) 				{ 					que.push(newP); 					preStep[newP.x][newP.y] = curP; 					mapArr[newP.x][newP.y] = 1; 				} 			} 		} 		if (!isFind) 		{ 			printf("can't reach!\n"); 			continue; 		} 		stack<Point> st; 		Point p(dx, dy); 		while (p.x != -1) 		{ 			st.push(p); 			p = preStep[p.x][p.y]; 		} 		printf("%d步: ", st.size()-1); 		bool start = false; 		while (!st.empty()) 		{ 			Point p = st.top(); 			st.pop(); 			if (start) 			{ 				printf(" -> "); 			} 			printf("(%d,%d)", p.x, p.y); 			start = true; 		} 		printf("\n"); 	}  }    /** problem E 给定一个正整数数组，a1,a2,...,an 初始玩家站在数组的第1个位置（为方便表述，认为数组下标从1开始），拥有a1的分数，玩家可以进行两种方式的移动： 1. 向右移动 - 从当前下标x移动到x+1以获得ax+1的分数。这个行为只有在x<n时才能进行。 2. 向左移动 - 从当前下标x移动到x-1以获得ax-1的分数。这个行为只有在x>1时才能进行。 玩家只能移动k次，其中向左移动不能超过z次。 求玩家可以获得的最高分数。 输入： 第一行包括一个整数t(1<=t<=10^4),样例的数量 每个样例的第一行包括3个整数，n,k和z（2<=n<=10^4,0<k-2*z<n,2*z<k,z<=100)）,分别表示数组元素个数，总共可移动的步数和向左移动的最大步数 第二行输入n个正整数，a1,a2,...an(1<ai<10^4) 输出 输出最大可获得的分数。  样例输入： 2 7 9 3 1 3 7 2 3 6 12 7 8 2 1 3 7 2 3 6 12 样例输出 52 58  这道题需要用动态规划的算法来解答： 1.什么是动态规划（5分） 2.解决该问题，需要怎样划分状态，数据结构如何设计（5分） 3.状态转移方程是什么(5分) 4.写出实现代码（15分）不使用动态规划，直接写出合理代码，亦可全分 */  /**  解析 该题考察动态规划的知识和数学应用能力 第1问： 动态规划是把一个大的问题分解成一个递推方式的解法，并且记录各状态的值，以免重复求取。 第2问： 该问题的状态是，向右移动的次数和向左移动的次数，可以使用一个二维数组记录状态 输入数组：int scoreArr[10001]; 状态数组：int state[10001][100]; 第3问： 定义移动次数是ki，向左移动次数是zi,则无论如何，最后一步一定踩到ki-2*zi+1处 状态转移方程是： state[ki][zi] = max(state[ki-1][zi] ,state[ki-1][zi-1] ) + scoreArr[ki-2*zi+1]  */ int pb5_scoreArr[10001]; int pb5_state[10001][101]; void problem5() { 	int T; 	scanf("%d", &T); 	while (T--) 	{ 		int n, k, z; 		scanf("%d%d%d", &n,&k,&z); 		for (int i = 1; i <= n; i++) 		{ 			scanf("%d", &pb5_scoreArr[i]); 		} 		//solve 		memset(pb5_state, 0, sizeof(pb5_state)); 		int ans = -1; 		pb5_state[0][0] = pb5_scoreArr[1]; 		for (int zi = 0; zi <= z; zi++) 		{ 			for (int ki = 1; ki <= k; ki++) 			{ 				if (ki >= 2*zi && ki-2*zi <= n) 				{ 					if (zi > 0) 						pb5_state[ki][zi] = max(pb5_state[ki - 1][zi], pb5_state[ki - 1][zi - 1]) + pb5_scoreArr[ki - 2*zi+1]; 					else 						pb5_state[ki][zi] = pb5_state[ki - 1][zi] + pb5_scoreArr[ki - 2*zi+1]; 				} 				ans = max(ans, pb5_state[ki][zi]); 				//printf("%d\t", pb5_state[ki][zi]); 			} 			//printf("\n"); 		} 		printf("%d\n", ans); 	} }      int main() { 	int iProblem; 	while (~scanf("%d", &iProblem)) 	{ 		switch (iProblem) 		{ 		case 1: 			problem1(); 			break; 		case 2: 			problem2(); 			break; 		case 3: 			problem3(); 			break; 		case 4: 			problem4(); 			break; 		case 5: 			problem5(); 			break; 		case -1: 			return 0; 		} 	} 	system("pause"); 	return 0; }